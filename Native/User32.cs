using System.Runtime.InteropServices;
using RainmeterFreeze.Native.Structures;
using RainmeterFreeze.Native.Enumerations;

namespace RainmeterFreeze.Native;

/// <summary>
/// Provides native methods from the USER32 Dynamic Link Library.
/// </summary>
static partial class User32
{
    /// <summary>
    /// An application-defined callback (or hook) function that the system calls
    /// in response to events generated by an accessible object. The hook
    /// function processes the event notifications as required. Clients install 
    /// the hook function and request specific types of event notifications by
    /// calling SetWinEventHook.
    /// </summary>
    /// <param name="hWinEventHook">Handle to an event hook function. This value is returned by SetWinEventHook when the hook function is installed and is specific to each instance of the hook function.</param>
    /// <param name="eventType">Specifies the event that occurred. This value is one of the event constants.</param>
    /// <param name="hwnd">Handle to the window that generates the event, or NULL if no window is associated with the event. For example, the mouse pointer is not associated with a window.</param>
    /// <param name="idObject">Identifies the object associated with the event. This is one of the object identifiers or a custom object ID.</param>
    /// <param name="idChild">Identifies whether the event was triggered by an object or a child element of the object. If this value is CHILDID_SELF, the event was triggered by the object; otherwise, this value is the child ID of the element that triggered the event.</param>
    /// <param name="dwmsEventTime">Specifies the time, in milliseconds, that the event was generated.</param>
    public delegate void WinEventDelegate(
        nint hWinEventHook,
        uint eventType,
        nint hwnd,
        int idObject,
        int idChild,
        uint dwEventThread,
        uint dwmsEventTime
    );

    /// <summary>
    /// The callback function is not mapped into the address space of the process that generates the event. Because the hook function is called across process boundaries, the system must queue events. Although this method is asynchronous, events are guaranteed to be in sequential order. 
    /// </summary>
    public const uint WinEventOutOfContext = 0;

    /// <summary>
    /// The foreground window has changed. The system sends this event even if the foreground window has changed to another window in the same thread. Server applications never send this event.
    /// For this event, the WinEventProc callback function's hwnd parameter is the handle to the window that is in the foreground, the idObject parameter is OBJID_WINDOW, and the idChild parameter is CHILDID_SELF.
    /// </summary>
    public const uint EventSystemForeground = 3;

    /// <summary>
    /// A window object is about to be minimized.
    /// </summary>
    public const uint EventSystemMinimizeStart = 0x0016;

    /// <summary>
    /// The window itself rather than a child object.
    /// </summary>
    public const uint ObjIdWindow = 0x00000000;

    /// <summary>
    /// An object has been destroyed. The system sends this event for the following user interface elements: caret, header control, list-view control, tab control, toolbar control, tree view control, and window object. Server applications send this event for their accessible objects.
    /// Clients assume that all of an object's children are destroyed when the parent object sends this event.
    /// After receiving this event, clients do not call an object's IAccessible properties or methods. However, the interface pointer must remain valid as long as there is a reference count on it (due to COM rules), but the UI element may no longer be present. Further calls on the interface pointer may return failure errors; to prevent this, servers create proxy objects and monitor their life spans.
    /// </summary>
    public const uint EventObjectDestroy = 0x8001;

    /// <summary>
    /// Posted to a window when the cursor moves. If the mouse is not captured, the message is posted to the window that contains the cursor. Otherwise, the message is posted to the window that has captured the mouse.
    /// </summary>
    public const uint WmMouseMove = 0x0200;

    /// <summary>
    /// Sets an event hook function for a range of events.
    /// </summary>
    /// <param name="eventMin">Specifies the event constant for the lowest event value in the range of events that are handled by the hook function.</param>
    /// <param name="eventMax">Specifies the event constant for the highest event value in the range of events that are handled by the hook function.</param>
    /// <param name="hmodWinEventProc">Handle to the DLL that contains the hook function at lpfnWinEventProc, if the WINEVENT_INCONTEXT flag is specified in the dwFlags parameter. If the hook function is not located in a DLL, or if the WINEVENT_OUTOFCONTEXT flag is specified, this parameter is NULL.</param>
    /// <param name="lpfnWinEventProc">Pointer to the event hook function.</param>
    /// <param name="idProcess">Specifies the ID of the process from which the hook function receives events. Specify zero (0) to receive events from all processes on the current desktop.</param>
    /// <param name="idThread">Specifies the ID of the thread from which the hook function receives events. If this parameter is zero, the hook function is associated with all existing threads on the current desktop.</param>
    /// <param name="dwFlags">Flag values that specify the location of the hook function and of the events to be skipped.</param>
    /// <returns></returns>
    [LibraryImport("user32.dll")]
    public static partial nint SetWinEventHook(
        uint eventMin,
        uint eventMax,
        nint hmodWinEventProc,
        WinEventDelegate lpfnWinEventProc,
        uint idProcess,
        uint idThread,
        uint dwFlags
    );

    /// <summary>
    /// Removes an event hook function created by a previous call to SetWinEventHook.
    /// </summary>
    /// <param name="hWinEventHook">Handle to the event hook returned in the previous call to SetWinEventHook.</param>
    /// <returns>If successful, returns TRUE; otherwise, returns FALSE.</returns>
    [LibraryImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static partial bool UnhookWinEvent(nint hWinEventHook);

    /// <summary>
    /// Retrieves a handle to the foreground window (the window with which the
    /// user is currently working). The system assigns a slightly higher priority
    /// to the thread that creates the foreground window than it does to other threads.
    /// </summary>
    /// <returns>The return value is a handle to the foreground window. The foreground window can be NULL in certain circumstances, such as when a window is losing activation.</returns>
    [LibraryImport("user32.dll")]
    public static partial nint GetForegroundWindow();

    /// <summary>
    /// Retrieves a handle to the desktop window. The desktop window
    /// covers the entire screen. The desktop window is the area on top
    /// of which other windows are painted.
    /// </summary>
    /// <returns>The return value is a handle to the desktop window.</returns>
    [LibraryImport("user32.dll")]
    public static partial nint GetDesktopWindow();

    /// <summary>
    /// Retrieves a handle to the Shell's desktop window.
    /// </summary>
    /// <returns>The return value is the handle of the Shell's desktop window. If no Shell process is present, the return value is NULL.</returns>
    [LibraryImport("user32.dll")]
    public static partial nint GetShellWindow();

    /// <summary>
    /// Retrieves a handle to the top-level window whose class name and window name match the specified strings. This function does not search child windows.
    /// This function does not perform a case-sensitive search.
    /// </summary>
    /// <param name="lpClassName">The class name or a class atom created by a previous call to the RegisterClass or RegisterClassEx function. The atom must be in the low-order word of lpClassName; the high-order word must be zero.</param>
    /// <param name="lpWindowName">The window name (the window's title). If this parameter is NULL, all window names match.</param>
    /// <returns>If the function succeeds, the return value is a handle to the window that has the specified class name and window name. If the function fails, the return value is NULL.</returns>
    [LibraryImport("user32.dll", EntryPoint = "FindWindowW", StringMarshalling = StringMarshalling.Utf16)]
    public static partial nint FindWindow(
        string lpClassName,
        string? lpWindowName
    );

    [LibraryImport("user32.dll", EntryPoint = "GetClassNameW", StringMarshalling = StringMarshalling.Utf16)]
    private static unsafe partial int GetClassName(
        nint hWnd,
        char* lpClassName,
        int nMaxCount
    );

    /// <summary>
    /// Retrieves the name of the class to which the specified window belongs.
    /// </summary>
    /// <param name="hWnd">A handle to the window and, indirectly, the class to which the window belongs.</param>
    /// <param name="lpClassName">The class name string.</param>
    /// <returns>If the function succeeds, the return value is the number of characters copied to the buffer, not including the terminating null character. If the function fails, the return value is zero.</returns>
    public static unsafe int GetClassName(nint hWnd, Span<char> lpClassName)
    {
        fixed (char* ptr = lpClassName) {
            return GetClassName(hWnd, ptr, lpClassName.Length - 1);
        }
    }

    /// <summary>
    /// Retrieves the identifier of the thread that created the specified
    /// window and, optionally, the identifier of the process that created
    /// the window.
    /// </summary>
    /// <param name="hWnd">A handle to the window.</param>
    /// <param name="processId">A pointer to a variable that receives the process identifier. If this parameter is not NULL, GetWindowThreadProcessId copies the identifier of the process to the variable; otherwise, it does not.</param>
    /// <returns>The return value is the identifier of the thread that created the window.</returns>
    [LibraryImport("user32.dll", SetLastError = true)]
    public static partial uint GetWindowThreadProcessId(
        nint hWnd,
        out uint processId
    );

    /// <summary>
    /// Determines whether a window is maximized.
    /// </summary>
    /// <param name="hWnd">A handle to the window to be tested.</param>
    [LibraryImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static partial bool IsZoomed(nint hWnd);

    /// <summary>
    /// Retrieves the dimensions of the bounding rectangle of the specified
    /// window. The dimensions are given in screen coordinates that are
    /// relative to the upper-left corner of the screen.
    /// </summary>
    /// <param name="hWnd">A handle to the window.</param>
    /// <param name="rect">A pointer to a RECT structure that receives the screen coordinates of the upper-left and lower-right corners of the window.</param>
    /// <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</returns>
    [LibraryImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static partial bool GetWindowRect(nint hWnd, ref Rect rect);

    /// <summary>
    /// Displays a modal dialog box that contains a system icon, a set of buttons, and a brief application-specific message, such as status or error information. The message box returns an integer value that indicates which button the user clicked.
    /// </summary>
    /// <param name="hWnd">A handle to the owner window of the message box to be created. If this parameter is NULL, the message box has no owner window.</param>
    /// <param name="lpText">The message to be displayed. If the string consists of more than one line, you can separate the lines using a carriage return and/or linefeed character between each line.</param>
    /// <param name="lpCaption">The dialog box title. If this parameter is NULL, the default title is Error.</param>
    /// <param name="type">The contents and behavior of the dialog box.</param>
    [LibraryImport("user32.dll", EntryPoint = "MessageBoxW", StringMarshalling = StringMarshalling.Utf16)]
    public static partial DialogResult MessageBox(
        nint hWnd,
        string lpText,
        string lpCaption,
        MessageBoxType type
    );

    /// <summary>
    /// The MonitorFromWindow function retrieves a handle to the display monitor that has the largest area of intersection with the bounding rectangle of a specified window.
    /// </summary>
    /// <param name="hwnd">A handle to the window of interest.</param>
    /// <param name="dwFlags">Determines the function's return value if the window does not intersect any display monitor.</param>
    [LibraryImport("user32.dll")]
    public static partial nint MonitorFromWindow(
        nint hwnd,
        MonitorFromWindowFlags dwFlags
    );

    /// <summary>
    /// The GetMonitorInfo function retrieves information about a display monitor.
    /// </summary>
    /// <param name="hMonitor">A handle to the display monitor of interest.</param>
    /// <param name="lpmi">A pointer to a MONITORINFO or MONITORINFOEX structure that receives information about the specified display monitor.</param>
    [LibraryImport("user32.dll", EntryPoint = "GetMonitorInfoW")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static partial bool GetMonitorInfo(
        nint hMonitor,
        ref MonitorInfo lpmi
    );

    /// <summary>
    /// Retrieves a message from the calling thread's message queue. The function dispatches incoming sent messages until a posted message is available for retrieval.
    /// </summary>
    /// <param name="lpMsg">A pointer to an MSG structure that receives message information from the thread's message queue.</param>
    /// <param name="hWnd">A handle to the window whose messages are to be retrieved. The window must belong to the current thread.</param>
    /// <param name="wMsgFilterMin">The integer value of the lowest message value to be retrieved.</param>
    /// <param name="wMsgFilterMax">The integer value of the highest message value to be retrieved.</param>
    /// <returns>If the function retrieves a message other than WM_QUIT, the return value is nonzero.</returns>
    [LibraryImport("user32.dll", EntryPoint = "GetMessageW")]
    public static partial int GetMessage(
        ref Msg lpMsg,
        nint hWnd,
        uint wMsgFilterMin,
        uint wMsgFilterMax
    );

    /// <summary>
    /// Dispatches a message to a window procedure. It is typically used to dispatch a message retrieved by the GetMessage function.
    /// </summary>
    /// <param name="lpMsg">A pointer to a structure that contains the message.</param>
    /// <returns>The return value specifies the value returned by the window procedure. Although its meaning depends on the message being dispatched, the return value generally is ignored.</returns>
    [LibraryImport("user32.dll", EntryPoint = "DispatchMessageW")]
    public static partial nint DispatchMessage(ref Msg lpMsg);

    /// <summary>
    /// Translates virtual-key messages into character messages. The character messages are posted to the calling thread's message queue, to be read the next time the thread calls the GetMessage or PeekMessage function.
    /// </summary>
    /// <param name="lpMsg">A pointer to an MSG structure that contains message information retrieved from the calling thread's message queue by using the GetMessage or PeekMessage function.</param>
    [LibraryImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static partial bool TranslateMessage(ref Msg lpMsg);

    public delegate bool EnumThreadDelegate(nint hWnd, nint lParam);

    /// <summary>
    /// Enumerates all nonchild windows associated with a thread by passing the handle to each window, in turn, to an application-defined callback function. EnumThreadWindows continues until the last window is enumerated or the callback function returns FALSE. To enumerate child windows of a particular window, use the EnumChildWindows function.
    /// </summary>
    /// <param name="dwThreadId">The identifier of the thread whose windows are to be enumerated.</param>
    /// <param name="lpfn">A pointer to an application-defined callback function. For more information, see EnumThreadWndProc.</param>
    /// <param name="lParam">An application-defined value to be passed to the callback function.</param>
    /// <returns>If the callback function returns TRUE for all windows in the thread specified by dwThreadId, the return value is TRUE. If the callback function returns FALSE on any enumerated window, or if there are no windows found in the thread specified by dwThreadId, the return value is FALSE.</returns>
    [LibraryImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static partial bool EnumThreadWindows(
        int dwThreadId,
        EnumThreadDelegate lpfn,
        nint lParam
    );

    // We can't use Func<...> here, unfortunately! :(
    // See https://github.com/dotnet/runtime/issues/113590 for more info.
    public delegate nint HookProc(int code, nuint wParam, nint lParam);

    /// <summary>
    /// Installs an application-defined hook procedure into a hook chain. You would install a hook procedure to monitor the system for certain types of events. These events are associated either with a specific thread or with all threads in the same desktop as the calling thread.
    /// </summary>
    /// <param name="idHook">The type of hook procedure to be installed.</param>
    /// <param name="lpfn">A pointer to the hook procedure. If the dwThreadId parameter is zero or specifies the identifier of a thread created by a different process, the lpfn parameter must point to a hook procedure in a DLL. Otherwise, lpfn can point to a hook procedure in the code associated with the current process.</param>
    /// <param name="hmod">A handle to the DLL containing the hook procedure pointed to by the lpfn parameter. The hMod parameter must be set to NULL if the dwThreadId parameter specifies a thread created by the current process and if the hook procedure is within the code associated with the current process.</param>
    /// <param name="dwThreadId">The identifier of the thread with which the hook procedure is to be associated. For desktop apps, if this parameter is zero, the hook procedure is associated with all existing threads running in the same desktop as the calling thread.</param>
    /// <returns>If the function succeeds, the return value is the handle to the hook procedure.</returns>
    [LibraryImport("user32.dll", EntryPoint = "SetWindowsHookExW")]
    public static partial nint SetWindowsHookEx(
        WindowsHookType idHook,
        HookProc lpfn,
        nint hmod,
        uint dwThreadId
    );

    /// <summary>
    /// Passes the hook information to the next hook procedure in the current hook chain. A hook procedure can call this function either before or after processing the hook information.
    /// </summary>
    /// <param name="hhk">This parameter is ignored.</param>
    /// <param name="nCode">The hook code passed to the current hook procedure. The next hook procedure uses this code to determine how to process the hook information.</param>
    /// <param name="wParam">The wParam value passed to the current hook procedure. The meaning of this parameter depends on the type of hook associated with the current hook chain.</param>
    /// <param name="lParam">The lParam value passed to the current hook procedure. The meaning of this parameter depends on the type of hook associated with the current hook chain.</param>
    /// <returns>This value is returned by the next hook procedure in the chain. The current hook procedure must also return this value. The meaning of the return value depends on the hook type. For more information, see the descriptions of the individual hook procedures.</returns>
    [LibraryImport("user32.dll")]
    public static partial nint CallNextHookEx(
        nint hhk,
        int nCode,
        nuint wParam,
        nint lParam
    );

    /// <summary>
    /// Removes a hook procedure installed in a hook chain by the SetWindowsHookEx function.
    /// </summary>
    /// <param name="hhk">A handle to the hook to be removed. This parameter is a hook handle obtained by a previous call to SetWindowsHookEx.</param>
    /// <returns>If the function succeeds, the return value is nonzero.</returns>
    [LibraryImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static partial bool UnhookWindowsHookEx(nint hhk);
}

enum MonitorFromWindowFlags
{
    DefaultToNull,
    DefaultToPrimary,
    DefaultToNearest,
}
